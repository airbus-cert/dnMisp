using ICSharpCode.SharpZipLib.Zip;
using System;
using System.Collections.Generic;
using System.IO;

namespace dnMisp.Misc
{
    public class MalwareArchiveReader
    {
        private byte[] _content;
        public MalwareArchiveReader(string base64)
            : this(Convert.FromBase64String(base64))
        {

        }

        public MalwareArchiveReader(byte[] binary)
        {
            _content = binary;
        }

        public MalwareArchiveReader(Stream stream)
        {
            BinaryReader binReader = new BinaryReader(stream);
            stream.Seek(0, SeekOrigin.Begin);
            _content = binReader.ReadBytes((int)stream.Length);
        }

        public byte[] Content
        {
            get
            {
                return _content;
            }
        }

        public Stream ToStream()
        {
            MemoryStream stream = new MemoryStream(_content);
            return stream;
        }

        public MalwareReader GetMalwareReader()
        {
            Dictionary<string, Stream> archivesFiles = Extract(ToStream());

            MalwareReader mr = new MalwareReader(archivesFiles);
            return mr;
        }


        public static Dictionary<string, Stream> Extract(Stream stream)
        {
            var di = ExtractZipStream(stream, "infected");
            if (di.Count > 0)
                return di;

            di = ExtractZipStream(stream, null);
            return di;
        }

        public static Dictionary<string, Stream> ExtractZipStream(Stream stream, string password)
        {
            Dictionary<string, Stream> result = new Dictionary<string, Stream>();

            ZipFile zf = null;
            try
            {
                zf = new ZipFile(stream);

                if (!string.IsNullOrEmpty(password))
                {
                    zf.Password = password;     // AES encrypted entries are handled automatically
                }

                foreach (ZipEntry zipEntry in zf)
                {
                    if (!zipEntry.IsFile)
                    {
                        continue;           // Ignore directories
                    }
                    string entryFileName = zipEntry.Name;

                    Stream zipStream = zf.GetInputStream(zipEntry);

                    MemoryStream memcpy = new MemoryStream();
                    zipStream.CopyTo(memcpy);
                    result.Add(entryFileName, memcpy);
                }
            }
            finally
            {
                if (zf != null)
                {
                    zf.IsStreamOwner = true; // Makes close also shut the underlying stream
                    zf.Close(); // Ensure we release resources
                }
            }
            return result;
        }
    }
}